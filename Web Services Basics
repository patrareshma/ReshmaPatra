Web services
As its name suggests, HTTP was originally designed to transfer hypertext documents, specifically HTML pages, from a server to a web browser on someone's desktop computer. Over time, though, people realized that they could send all sorts of other types of files over HTTP (and thus over "the Web"). There are many reasons to do so. HTTP is, compared to many alternatives, a fairly simple protocol. It also has a lot of really nice features baked in, such as caching and validation. There's no central authority which means anyone can setup a client or server and it "just works." HTTP uses ad-hoc, as-needed connections, which means it scales extremely well. Perhaps most importantly, though, many corporate networks in the late 1990s blocked nearly all outgoing traffic in the name of security, except for HTTP over port 80. That meant for many applications, using HTTP was the only way they could get through corporate firewalls.

For various reasons, then, developers started sending messages back and forth over HTTP that were not HTML pages destined for browsers, but arbitrary data intended for other programs to read and respond to. Collectively, these are known as "Web services," that is, a "service" that a program can connect to "over the Web" and do stuff. Strictly speaking, browsers and HTML pages are a subset of that (the service being a web server, the client being a browser, and "do stuff" being "send an HTML page"), but in practice a "Web service" has come to mean "doing stuff over HTTP that is not showing an HTML page in a web browser."

That leaves a whole host of options. Various formal or informal specifications for communicating non-HTML-stuff over HTTP sprang up, such as SOAP or XML-RPC. Those are both web-service formats (essentially alternatives to HTML that mean different things), but only examples. These days both are rarely used, in favor of a variety of more loosely defined approaches that fit better with the way HTTP works.

REpresentational State Transfer
One particular style of Web service approach is called REST, short for REpresentational State Transfer. REST is not a specific API format per se; rather, it is an abstract model of how an API could be designed. HTTP 1.1 itself was deliberately written to support a REST-style architecture, but not everything that happens over HTTP follows that architectural style.

The RESTful architectural style includes a number of features:

It is a client-server architecture; any client can connect to any server over a known, specified protocol.
It's stateless; Or rather, the server's knowledge of the client is stateless. Every time a client connects to a server, the server starts with no knowledge of any prior communication. Keeping track of state or history is the client's job. That's part of what makes HTTP so scalable.
Responses are cacheable; because communication is stateless, an identical request should, in most cases, return an identical response. We can rely on that fact to allow either a client or an intermediary server to cache responses, vastly improving performance.
Uniformly identified resources; every "resource" in a RESTful network is uniquely identified by some address, and that address is unique to that resource. On the Web, this means a URL, or as it's generally called formally: a URI (Uniform Resource Identifier). The URI, for example: http://www.drupal.org/download has a strict 1:1 relationship with "the download page of Drupal."
Resources are represented in some format, and that's how clients talk to the server. That format could be HTML, but also a JSON string, or a PDF, or an SVG image. All are just representations of the underlying platonic "resource thing."
Messages are self-descriptive; what the message wants to do, what representation it's using, and so on are contained in the message itself rather than relying on some external context or assumption. (This goes back to the stateless part.)
Hypermedia links; A server informs a client what it can do to a given resource by means of links to other resources that are included with the resource. The client knows only what the links tell it, and has no implicit knowledge of what else it can do.
